# [33. Search in Rotated Sorted Array][link] (Medium)

[link]: https://leetcode.cn/problems/search-in-rotated-sorted-array/
## 33. Поиск в повернутом отсортированном массиве

**Уровень:** Средний  
**Темы:** Бинарный поиск, Массивы

Дан целочисленный массив `nums`, отсортированный по возрастанию (с **уникальными** значениями).

Перед передачей в вашу функцию массив **мог быть повернут** на некотором неизвестном индексе `k` (`1 <= k < nums.length`), так что стал выглядеть как  
`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`.

Например, массив `[0,1,2,4,5,6,7]`, повернутый на индексе 3, становится `[4,5,6,7,0,1,2]`.

Вам дан массив `nums` **после поворота** и целое число `target`.  
Необходимо вернуть **индекс элемента `target`**, если он есть в массиве, либо `-1`, если его нет.

> **Необходимо реализовать алгоритм со временем выполнения `O(log n)`**.

---

### Примеры:

**Пример 1:**
```
Вход: nums = [4,5,6,7,0,1,2], target = 0  
Выход: 4
```

**Пример 2:**
```
Вход: nums = [4,5,6,7,0,1,2], target = 3  
Выход: -1
```

**Пример 3:**
```
Вход: nums = [1], target = 0  
Выход: -1
```

---

### Ограничения:

- `1 <= nums.length <= 5000`
- `-10⁴ <= nums[i] <= 10⁴`
- Все элементы `nums` **уникальны**
- `nums` — это **отсортированный массив, возможно повернутый**
- `-10⁴ <= target <= 10⁴`

